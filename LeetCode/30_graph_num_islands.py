from typing import List 

class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        n = len(grid[0])

        def bfs(i, j):
            queue = [(i,j)]
            while len(queue) > 0:
                index = queue.pop(0)
                grid[index[0]][index[1]] = 'C' # Mark as checked in place
                for (r,c) in [(-1,0), (1,0), (0,-1), (0,1)]:
                    new_row, new_col = index[0] + r, index[1] + c
                    if 0 <= new_row and new_row < m and 0 <=new_col and new_col < n \
                        and grid[new_row][new_col] == "1":
                        grid[new_row][new_col] = 'Q' # Mark as queued to avoid repeats
                        # ^ YOU GOT THIS WRONG, THIS PREVENTS RE-EXPLORE
                        queue.append((new_row, new_col))
        
        # Iterate through the cells
        count = 0
        for i in range(0, m):
            for j in range(0, n):
                if grid[i][j] == "1":
                    bfs(i, j)
                    count += 1

        return count
                    
print(Solution().numIslands([["1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","0","1","0","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","0"],["1","0","1","1","1","0","0","1","1","0","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","0","1","1","1","1","1","1","0","1","1","1","0","1","1","1","0","1","1","1"],["0","1","1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","1","1"],["1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["0","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","0","1","1","1","1","1","1","1","0","1","1","1","1","1","1"],["1","0","1","1","1","1","1","0","1","1","1","0","1","1","1","1","0","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","0"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"]]))

"""
You need to remember for BFS to mark as checked or explored every at the queue appended stage.
Queues and Checked might have different implications for algos like building a DAG.
O.t.w you get a runtime error.

If you need to do calculations in place, use sets for O(n) space.
Since no calculations are needed, you can run in O(MN) time and O(1) space...
"""